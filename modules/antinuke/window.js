export class InMemoryKV{constructor(){this.store=new Map()}get(k){return this.store.get(k)}set(k,v){this.store.set(k,v)}has(k){return this.store.has(k)}keys(){return Array.from(this.store.keys())}}export class SlidingWindowCounter{constructor({windowMs,now=()=>Date.now(),kv=new InMemoryKV()}){if(!Number.isFinite(windowMs)||windowMs<=0)throw new Error("windowMs must be > 0");this.windowMs=windowMs;this.now=now;this.kv=kv}_bucketKey(e){return`bucket:${e}`}increment(e,c=1){if(!e)throw new Error("eventType required");if(!Number.isFinite(c)||c<=0)throw new Error("count must be > 0");const k=this._bucketKey(e);const arr=this.kv.get(k)||[];const t=this.now();for(let i=0;i<c;i++)arr.push(t);this.kv.set(k,this._prune(arr,t))}snapshot(eventTypes){const t=this.now();const snap={};for(const et of eventTypes){const k=this._bucketKey(et);const arr=this.kv.get(k)||[];const pruned=this._prune(arr,t);this.kv.set(k,pruned);snap[et]=pruned.length}return{ts:t,windowMs:this.windowMs,counts:snap}}_prune(arr,now){const cutoff=now-this.windowMs;let i=0;while(i<arr.length&&arr[i]<cutoff)i++;return i===0?arr:arr.slice(i)}}